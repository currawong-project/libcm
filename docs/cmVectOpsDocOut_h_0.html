<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>cmVectOpsDocOut.h</title>
    <link href="cdg_code.css"    rel="stylesheet" type="text/css" media="screen" />
  </head>
  <body>
    <div class="highlight">

      <div class="license">
	<p>
	  Copyright (C) Kevin Larke 2009-2020
	</p>

	<p>
	  This file is part of libcm.
	</p>

	<p>
	  libcm is free software: you can redistribute it and/or modify it under
	  the terms of the GNU General Public License as published by the Free
	  Software Foundation, either version 3 of the License, or (at your
	  option) any later version.
	</p>

	<p>
	  libcm is distributed in the hope that it will be useful, but WITHOUT
	  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
	  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
	  for more details.
	</p>

	<p>
	  See the GNU General Public License distributed with the libcm
	  package or look here: <https://www.gnu.org/licenses/>.
	</p>


      </div>

      <hr>
<a name="cmVectOpsDocOut.h"></a><!-- Begin nodes -->
<div class="cod"><div class="blk_title">misc : Miscellaneous vector operations.</div><pre><a name="misc"></a>
<span class="c">// Compute the cummulative sum of sbp[dn]. Equivalent to Matlab cumsum().</span>
T_t<span class="p">*</span> <a name="cmVOT_CumSum"></a><span class="f">cmVOT_CumSum</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Returns true if all values in each vector are equal.</span>
<span class="k">bool</span>          <a name="cmVOT_Equal"></a><span class="f">cmVOT_Equal</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Same as Matlab linspace() v[i] = i * (limit-1)/n</span>
T_t<span class="p">*</span>  <a name="cmVOT_LinSpace"></a><span class="f">cmVOT_LinSpace</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">base</span><span class="p">,</span> T_t <span class="i">limit</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Print : Vector printing functions.</div><pre><a name="Print"></a><span class="c">// Setting fieldWidth or decPltCnt to to negative values result in fieldWidth == 10 or decPlCnt == 4
//</span>
<span class="k">void</span>          <a name="cmVOT_Printf"></a><span class="f">cmVOT_Printf</span><span class="p">(</span> <a href="cmRpt_h_0.html#cmRpt_t">cmRpt_t</a><span class="p">*</span> <span class="i">rpt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">int</span> <span class="i">fieldWidth</span><span class="p">,</span> <span class="k">int</span> <span class="i">decPlCnt</span><span class="p">,</span> <span class="k">const</span> <span class="k">char</span><span class="p">*</span> <span class="i">fmt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">flags</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span>          <a name="cmVOT_Print"></a><span class="f">cmVOT_Print</span><span class="p">(</span>  <a href="cmRpt_h_0.html#cmRpt_t">cmRpt_t</a><span class="p">*</span> <span class="i">rpt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dbp</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span>          <a name="cmVOT_PrintE"></a><span class="f">cmVOT_PrintE</span><span class="p">(</span> <a href="cmRpt_h_0.html#cmRpt_t">cmRpt_t</a><span class="p">*</span> <span class="i">rpt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dbp</span> <span class="p">)</span><span class="p">;</span>

<span class="k">void</span>          <a name="cmVOT_PrintLf"></a><span class="f">cmVOT_PrintLf</span><span class="p">(</span> <span class="k">const</span> <span class="k">char</span><span class="p">*</span> <span class="i">label</span><span class="p">,</span> <a href="cmRpt_h_0.html#cmRpt_t">cmRpt_t</a><span class="p">*</span> <span class="i">rpt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">fieldWidth</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">decPlCnt</span><span class="p">,</span> <span class="k">const</span> <span class="k">char</span><span class="p">*</span> <span class="i">fmt</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span>          <a name="cmVOT_PrintL"></a><span class="f">cmVOT_PrintL</span><span class="p">(</span>  <span class="k">const</span> <span class="k">char</span><span class="p">*</span> <span class="i">label</span><span class="p">,</span> <a href="cmRpt_h_0.html#cmRpt_t">cmRpt_t</a><span class="p">*</span> <span class="i">rpt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dbp</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span>          <a name="cmVOT_PrintLE"></a><span class="f">cmVOT_PrintLE</span><span class="p">(</span> <span class="k">const</span> <span class="k">char</span><span class="p">*</span> <span class="i">label</span><span class="p">,</span> <a href="cmRpt_h_0.html#cmRpt_t">cmRpt_t</a><span class="p">*</span> <span class="i">rpt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dbp</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Normalization : Normalization and standardization functions.</div><pre><a name="Normalization"></a>
<span class="c">// Normalize the vector of proabilities by dividing through by the sum.
// This leaves the relative proportions of each value unchanged while producing a total probability of 1.0.
//</span>
T_t<span class="p">*</span> <a name="cmVOT_NormalizeProbabilityVV"></a><span class="f">cmVOT_NormalizeProbabilityVV</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_NormalizeProbability"></a><span class="f">cmVOT_NormalizeProbability</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_NormalizeProbabilityN"></a><span class="f">cmVOT_NormalizeProbabilityN</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span><span class="p">)</span><span class="p">;</span>
<span class="c">//
// Standardize the columns of the matrix by subtracting the mean and dividing by the standard deviation.
// uV[dcn] returns the mean of the data and is optional.
// sdV[dcn] return the standard deviation of the data and is optional.</span>
T_t<span class="p">*</span> <a name="cmVOT_StandardizeRows"></a><span class="f">cmVOT_StandardizeRows</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">uV</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">sdV</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_StandardizeCols"></a><span class="f">cmVOT_StandardizeCols</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">uV</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">sdV</span> <span class="p">)</span><span class="p">;</span>
<span class="c">//
// Normalize by dividing through by the max. value.
// dp[] ./= max(dp). Returns the index of the max value.</span>
<span class="k">unsigned</span>  <a name="cmVOT_NormToMax"></a><span class="f">cmVOT_NormToMax</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>
<span class="c">//
// Normalize by dividing through by the max. absolute value.
// db[] .*= fact / abs(max(dp));</span>
<span class="k">unsigned</span> <a name="cmVOT_NormToAbsMax"></a><span class="f">cmVOT_NormToAbsMax</span><span class="p">(</span>   T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">fact</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Mean and variance : Compute mean and variance.</div><pre><a name="Mean and variance"></a>
T_t  <a name="cmVOT_Mean"></a><span class="f">cmVOT_Mean</span><span class="p">(</span>     <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_MeanN"></a><span class="f">cmVOT_MeanN</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span>  <span class="p">)</span><span class="p">;</span>
<span class="c">//
// Take the mean of each column/row of a matrix.
// Set 'dim' to 0 to return mean of columns else return mean of rows.</span>
T_t<span class="p">*</span>  <a name="cmVOT_MeanM"></a><span class="f">cmVOT_MeanM</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dim</span> <span class="p">)</span><span class="p">;</span>
<span class="c">//
// Take the mean of the first 'cnt' element of each column/row of a matrix.
// Set 'dim' to 0 to return mean of columns else return mean of rows.
// If 'cnt' is greater than the number of elements in the column/row then 'cnt' is
// reduced to the number of elements in the column/row.</span>
T_t<span class="p">*</span>  <a name="cmVOT_MeanM2"></a><span class="f">cmVOT_MeanM2</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dim</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cnt</span> <span class="p">)</span><span class="p">;</span>
<span class="c">//
// Find the mean of the  data points returned by srcFuncPtr(argPtr,i) and return it in dp[dim].
// 'dim' is both the size of dp[] and the length of each data point returned by srcFuncPtr().
// srcFuncPtr() will be called 'cnt' times but it may return NULL on some calls if the associated
// data point should not be included in the mean calculation.</span>
T_t<span class="p">*</span>  <a name="cmVOT_Mean2"></a><span class="f">cmVOT_Mean2</span><span class="p">(</span>   T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="p">(</span><span class="p">*</span><span class="i">srcFuncPtr</span><span class="p">)</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="i">arg</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">idx</span> <span class="p">)</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dim</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cnt</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="i">argPtr</span> <span class="p">)</span><span class="p">;</span>
<span class="c">//
// avgPtr is optional - set to NULL to compute the average</span>
T_t  <a name="cmVOT_Variance"></a><span class="f">cmVOT_Variance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">avgPtr</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_VarianceN"></a><span class="f">cmVOT_VarianceN</span><span class="p">(</span><span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">avgPtr</span> <span class="p">)</span><span class="p">;</span>
<span class="c">//
// Set dim=0 to return variance of columns otherwise return variance or rows.</span>
T_t<span class="p">*</span>  <a name="cmVOT_VarianceM"></a><span class="f">cmVOT_VarianceM</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span>  <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">avgPtr</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dim</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Covariance : Matrix covariance</div><pre><a name="Covariance"></a>
<span class="c">// Calculate the sample covariance matrix from a set of Gaussian distributed multidimensional data.
// sp[dn,scn] is the data set.
// dn is the dimensionality of the data.
// scn is the count of data points
// up[dn] is an optional mean vector. If up == NULL then the mean of the data is calculated internally. 
// selIdxV[scn] can be used to select a subset of datapoints to process.
// If selIdxV[] is non-NULL then only columns where selIdxV[i]==selKey will be processed.
//
// dp[dn,dn] = covar( sp[dn,scn], u[dn] )</span>
<span class="k">void</span>  <a name="cmVOT_GaussCovariance"></a><span class="f">cmVOT_GaussCovariance</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">up</span><span class="p">,</span> <span class="k">const</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">selIdxV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">selKey</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Calculate the sample covariance matrix.
// dp[ dn*dn ] - output matrix
// dn - dimensionality of the data
// srcFuncPtr - User defined function which is called to return a pointer to a data vector at index 'idx'.
//          The returned data vector must contain 'dn' elements.  The function should return NULL
//          if the data point associated with 'idx' should not be included in the covariance calculation.
// sn - count of data vectors 
// userPtr - User arg. passed to srcFuncPtr.    
// uV[ dn ] - mean of the data set (optional)
// Note that this function computes the covariance matrix in 2 serial passes (1 if the mean vector is given)
// through the 'sn' data points.  
// The result of this function are identical to the octave cov() function.</span>
<span class="k">void</span>  <a name="cmVOT_GaussCovariance2"></a><span class="f">cmVOT_GaussCovariance2</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="p">(</span><span class="p">*</span><span class="i">srcFuncPtr</span><span class="p">)</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">idx</span><span class="p">)</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">uV</span><span class="p">,</span> <span class="k">const</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">selIdxV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">selKey</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Float point normal : Evaluate the 'normalness of floating point values.</div><pre><a name="Float point normal"></a>
<span class="c">// Returns true if all values are 'normal' according the the C macro 'isnormal'.
// This function will return false if any of the values are zero.</span>
<span class="k">bool</span>          <a name="cmVOT_IsNormal"></a><span class="f">cmVOT_IsNormal</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Returns true if all values are 'normal' or zero according the the C macro 'isnormal'.
// This function accepts zeros as normal.</span>
<span class="k">bool</span>          <a name="cmVOT_IsNormalZ"></a><span class="f">cmVOT_IsNormalZ</span><span class="p">(</span><span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Set dp[dn] to the indexes of the non-normal numbers in sp[dn].
// Returns the count of indexes stored in dp[].</span>
<span class="k">unsigned</span>      <a name="cmVOT_FindNonNormal"></a><span class="f">cmVOT_FindNonNormal</span><span class="p">(</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_FindNonNormalZ"></a><span class="f">cmVOT_FindNonNormalZ</span><span class="p">(</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Measure : Measure features of a vector.</div><pre><a name="Measure"></a>
<span class="c">// Successive call to to ZeroCrossCount should preserve the value pointed to by delaySmpPtr.</span>
<span class="k">unsigned</span>      <a name="cmVOT_ZeroCrossCount"></a><span class="f">cmVOT_ZeroCrossCount</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">n</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">delaySmpPtr</span><span class="p">)</span><span class="p">;</span>

<span class="c">// Calculuate the sum of the squares of all elements in bp[bn]. </span>
T_t <a name="cmVOT_SquaredSum"></a><span class="f">cmVOT_SquaredSum</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">bp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// sn must be &amplt= wndSmpCnt. If sn &amplt wndSmpCnt then sp[sn] is treated as a
// a partially filled buffer padded with wndSmpCnt-sn zeros.
// rms = sqrt( sum(sp[1:sn] .* sp[1:sn]) / wndSmpCnt )</span>
T_t  <a name="cmVOT_RMS"></a><span class="f">cmVOT_RMS</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">wndSmpCnt</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// This function handles the case were sn is not an integer multiple of 
// wndSmpCnt or hopSmpCnt.  In this case the function computes zero 
// padded RMS values for windows which go past the end of sp[sn].</span>
T_t<span class="p">*</span> <a name="cmVOT_RmsV"></a><span class="f">cmVOT_RmsV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">wndSmpCnt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">hopSmpCnt</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the magnitude (Euclidean Norm) of a vector.</span>
T_t  <a name="cmVOT_EuclidNorm"></a><span class="f">cmVOT_EuclidNorm</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

T_t  <a name="cmVOT_AlphaNorm"></a><span class="f">cmVOT_AlphaNorm</span><span class="p">(</span><span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> T_t <span class="i">alpha</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Distance : Calculate various vector distances.</div><pre><a name="Distance"></a>
<span class="c">// Return the Itakura-Saito distance between a modelled power spectrum (up) and another power spectrum (sp).</span>
T_t <a name="cmVOT_ItakuraDistance"></a><span class="f">cmVOT_ItakuraDistance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">up</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the cosine distance between two vectors.</span>
T_t  <a name="cmVOT_CosineDistance"></a><span class="f">cmVOT_CosineDistance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0P</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the Euclidean distance between two vectors</span>
T_t  <a name="cmVOT_EuclidDistance"></a><span class="f">cmVOT_EuclidDistance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the Manhattan distance between two vectors</span>
T_t  <a name="cmVOT_L1Distance"></a><span class="f">cmVOT_L1Distance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the Mahalanobis distance between a vector and the mean of the distribution.
// The mean vector could be replaced with another vector drawn from the same distribution in which
// case the returned value would reflect the distance between the two vectors.
// 'sn' is the dimensionality of the data.
// up[D] and invCovM[sn,sn] are the mean and inverse of the covariance matrix of the distribution from 
// which sp[D] is drawn. </span>
T_t  <a name="cmVOT_MahalanobisDistance"></a><span class="f">cmVOT_MahalanobisDistance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">up</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">invCovM</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the KL distance between two probability distributions up[sn] and sp[sn].
// Since up[] and sp[] are probability distributions they must sum to 1.0.</span>
T_t <a name="cmVOT_KL_Distance"></a><span class="f">cmVOT_KL_Distance</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">up</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the KL distance between a prototype vector up[sn] and another vector sp[sn].
// This function first normalizes the two vectors to sum to 1.0 before calling
// <a href="#cmVOT_KL_Distance">cmVOT_KL_Distance</a>(up,sp,sn);</span>
T_t <a name="cmVOT_KL_Distance2"></a><span class="f">cmVOT_KL_Distance2</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">up</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// <a href="#Measure">Measure</a> the Euclidean distance between a vector and all the columns in a matrix.
// If dv[scn] is no NULL then return the Euclidean distance from sv[scn] to each column of sm[srn,scn].
// The function returns the index of the closest data point (column) in sm[].</span>
<span class="k">unsigned</span> <a name="cmVOT_EuclidDistanceVM"></a><span class="f">cmVOT_EuclidDistanceVM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dv</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sv</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sm</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// <a href="#Measure">Measure</a> the distance between each column in s0M[ rn, s0cn ] and 
// each column in s1M[rn, s1cn ]. If dM is non-NULL store the 
// result in dM[s1cn, s0cn]. The difference between s0M[:,0] and s1M[:,0] 
// is stored in dM[0,0], the diff. between s0M[:,1] and s1M[:,1] is stored 
// in dM[1,0], etc.  If mvV[s0cn] is non-NULL then  minV[i] is set with
// the distance from s0M[:,i] to the nearest column in s1M[]. If miV[s0cn]
// is non-NULL then it is set with the column index of s1M[] which is
// closest to s0M[:,i].  In other words mvV[i] gives the distance to column
// miV[i] from column s0M[:,i].
// In those cases where the distane from a prototype (centroid) to the data point
// is not the same as from the data point to the centroid then s1M[] is considered
// to hold the prototypes and s0M[] is considered to hold the data points.
// The distance function returns the distance from a prototype 'cV[dimN]' to
// an datapoint dV[dimN]. 'dimN' is the dimensionality of the data vector
// and is threfore equal to 'rn'.</span>
<span class="k">void</span> <a name="cmVOT_DistVMM"></a>cmVOT_DistVMM<span class="p">(</span> 
T_t<span class="p">*</span>       <span class="i">dM</span><span class="p">,</span>    <span class="c"> // dM[s1cn,s0cn] return distance mtx (optional) </span>
T_t<span class="p">*</span>       <span class="i">mvV</span><span class="p">,</span>   <span class="c"> // mvV[s0cn] distance to closest data point in s0M[]. (optional)</span>
<span class="k">unsigned</span><span class="p">*</span>           <span class="i">miV</span><span class="p">,</span>   <span class="c"> // miV[s0cn] column index into s1M[] of closest data point to s0M[:,i]. (optional)</span>
<span class="k">unsigned</span>            <span class="i">rn</span><span class="p">,</span>    <span class="c"> // dimensionality of the data and the row count for s0M[] and s1M[] </span>
<span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0M</span><span class="p">,</span>   <span class="c"> // s0M[rn,s0cn] contains one data point per column</span>
<span class="k">unsigned</span>            <span class="i">s0cn</span><span class="p">,</span>  <span class="c"> // count of data points (count of columns in s0M[]</span>
<span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1M</span><span class="p">,</span>   <span class="c"> // s1M[rn,s1cn] contains one prototype per column</span>
<span class="k">unsigned</span>            <span class="i">s1cn</span><span class="p">,</span>  <span class="c"> // count of prototypes (count of columns in s1m[]</span>
T_t <span class="p">(</span><span class="p">*</span><span class="i">distFunc</span><span class="p">)</span><span class="p">(</span> <span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">cV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dimN</span> <span class="p">)</span><span class="p">,</span> 
<span class="k">void</span><span class="p">*</span>               <span class="i">userPtr</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Select columns : Select columns based on distance.</div><pre><a name="Select columns"></a>
<span class="c">// Select 'selIdxN' columns from sM[srn,scn].
// dM[srn,selIdxN] receives copies of the selected columns.
// selIdxV[selIdxN] receives the column indexes of the selected columns.
// Both dM[] and selIdxV[] are optional.
// In each case the first selected point is chosen at random.
// SelectRandom() then selects the following selIdxN-1 points at random.
// SelectMaxDist() selects the next selIdxN-1 points by selecting 
// the point whose combined distance to the previously selected points
// is greatest. SelectMaxAvgDist() selectes the points whose combined
// average distance is greatest relative the the previously selected
// points.</span>
<span class="k">void</span> <a name="cmVOT_SelectRandom"></a><span class="f">cmVOT_SelectRandom</span><span class="p">(</span>     T_t<span class="p">*</span> <span class="i">dM</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">selIdxV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">selIdxN</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sM</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span> <a name="cmVOT_SelectMaxDist"></a><span class="f">cmVOT_SelectMaxDist</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dM</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">selIdxV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">selIdxN</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sM</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> T_t <span class="p">(</span><span class="p">*</span><span class="i">distFunc</span><span class="p">)</span><span class="p">(</span> <span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0V</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1V</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="i">distUserPtr</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span> <a name="cmVOT_SelectMaxAvgDist"></a><span class="f">cmVOT_SelectMaxAvgDist</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dM</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">selIdxV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">selIdxN</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sM</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> T_t <span class="p">(</span><span class="p">*</span><span class="i">distFunc</span><span class="p">)</span><span class="p">(</span> <span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0V</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1V</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">,</span> <span class="k">void</span><span class="p">*</span> <span class="i">distUserPtr</span> <span class="p">)</span><span class="p">;</span> 

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Matrix multiplication : Various matrix multiplication operations.</div><pre><a name="Matrix multiplication"></a>
<span class="c">// Return the sum of the products (dot product)</span>
T_t <a name="cmVOT_MultSumVV"></a><span class="f">cmVOT_MultSumVV</span><span class="p">(</span>  <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span>  <span class="p">)</span><span class="p">;</span>
T_t <a name="cmVOT_MultSumVS"></a><span class="f">cmVOT_MultSumVS</span><span class="p">(</span>  <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Number of elements in the dest vector is expected to be the same 
// as the number of source matrix rows.
// mcn gives the number of columns in the source matrix which is 
//  expected to match the number of elements in the source vector.
// dbp[dn,1] = mp[dn,mcn] * vp[mcn,1] </span>
T_t<span class="p">*</span> <a name="cmVOT_MultVMV"></a><span class="f">cmVOT_MultVMV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">mp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">mcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">vp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Multiply a row vector with a matrix to produce a row vector. 
// dbp[1,dn] = v[1,vn] * m[vn,dn]</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVVM"></a><span class="f">cmVOT_MultVVM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">vp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">vn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">mp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Same as MultVMtV() except M is transposed as part of the multiply.  
// mrn gives the number of rows in m[] and number of elements in vp[]
// dpb[dn] = mp[mrn,dn] * vp[mrn]</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVMtV"></a><span class="f">cmVOT_MultVMtV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">mp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">mrn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">vp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Same as MultVMV() but where the matrix is diagonal.</span>
T_t<span class="p">*</span> <a name="cmVOT_MultDiagVMV"></a><span class="f">cmVOT_MultDiagVMV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">mp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">mcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">vp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Generalized matrix multiply.
// If transposition is selected for M0 or M1 then the given dimension represent the size of the matrix 'after' the transposion. 
// d[drn,dcn] = alpha * op(m0[drn,m0cn_m1rn]) * op(m1[m0cn_m1rn,dcn]) + beta * d[drn,dcn]
/// See enum { kTranpsoseM0Fl=0x01, kTransposeM1Fl=0x02 } in cmVectOps for flags.</span>
T_t<span class="p">*</span> <a name="cmVOT_MultMMM1"></a><span class="f">cmVOT_MultMMM1</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> T_t <span class="i">alpha</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m1</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">m0cn_m1rn</span><span class="p">,</span> T_t <span class="i">beta</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">flags</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Same a <a href="#cmVOT_MultMMM1">cmVOT_MultMMM1</a> except allows the operation on a sub-matrix by providing the physical (memory) row count rather than the logical (matrix) row count.</span>
T_t<span class="p">*</span> <a name="cmVOT_MultMMM2"></a><span class="f">cmVOT_MultMMM2</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> T_t <span class="i">alpha</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m1</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">m0cn_m1rn</span><span class="p">,</span> T_t <span class="i">beta</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">flags</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dprn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">m0prn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">m1prn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// d[drn,dcn] = m0[drn,m0cn] * m1[m1rn,dcn] </span>
T_t<span class="p">*</span> <a name="cmVOT_MultMMM"></a><span class="f">cmVOT_MultMMM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m1</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">m0cn_m1rn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// same as MultMMM() except second source matrix is transposed prior to the multiply</span>
T_t<span class="p">*</span> <a name="cmVOT_MultMMMt"></a><span class="f">cmVOT_MultMMMt</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m1</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">m0cn_m1rn</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Linear algebra : Miscellaneous linear algebra operations. Determinant, Inversion, Cholesky decompostion. Linear system solver.</div><pre><a name="Linear algebra"></a>
<span class="c">// Initialize dbp[dn,dn] as a square symetric positive definite matrix using values
// from a random uniform distribution. This is useful for initializing random 
// covariance matrices as used by multivariate Gaussian distributions
// If t is non-NULL it must point to a block of scratch memory of t[dn,dn].
// If t is NULL then scratch memory is internally allocated and deallocated.</span>
T_t<span class="p">*</span> <a name="cmVOT_RandSymPosDef"></a><span class="f">cmVOT_RandSymPosDef</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">t</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Compute the determinant of any square matrix.</span>
T_t  <a name="cmVOT_DetM"></a><span class="f">cmVOT_DetM</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Compute the determinant of a diagonal matrix.</span>
T_t  <a name="cmVOT_DetDiagM"></a><span class="f">cmVOT_DetDiagM</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">)</span><span class="p">;</span>

<span class="c">// Compute the log determinant of any square matrix.</span>
T_t  <a name="cmVOT_LogDetM"></a><span class="f">cmVOT_LogDetM</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Compute the log determinant of a diagonal matrix.</span>
T_t  <a name="cmVOT_LogDetDiagM"></a><span class="f">cmVOT_LogDetDiagM</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">)</span><span class="p">;</span>


<span class="c">// Compute the inverse of a square matrix.  Returns NULL if the matrix is not invertable.
// 'drn' is the dimensionality of the data.</span>
T_t<span class="p">*</span> <a name="cmVOT_InvM"></a><span class="f">cmVOT_InvM</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Compute the inverse of a diagonal matrix. Returns NULL if the matrix is not invertable.</span>
T_t<span class="p">*</span> <a name="cmVOT_InvDiagM"></a><span class="f">cmVOT_InvDiagM</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Solve a linear system of the form AX=B where A[an,an] is square. 
// Since A is square B must have 'an' rows.
// Result is returned in B.
// Returns a pointer to B on success or NULL on fail.
// NOTE: Both A and B are overwritten by this operation.</span>
T_t<span class="p">*</span> <a name="cmVOT_SolveLS"></a><span class="f">cmVOT_SolveLS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">A</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">an</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">B</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bcn</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Perform a Cholesky decomposition of the square symetric matrix U[un,un].
// The factorization has the form: A=U'TU.
// If the factorization is successful A is set to U and a pointer to A is returned.
// Note that the lower triangle of A is not overwritten. See CholZ().
// If the factorization fails NULL is returned.</span>
T_t<span class="p">*</span> <a name="cmVOT_Chol"></a><span class="f">cmVOT_Chol</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">A</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">an</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Same as Chol() but sets the lower triangle of U to zero. 
// This is equivalent ot the Matlab version.</span>
T_t<span class="p">*</span> <a name="cmVOT_CholZ"></a><span class="f">cmVOT_CholZ</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">U</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">un</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Calculate the best fit line: b0 + b1*x_i through the points x_i,y_i.
// Set x to NULL if it uses sequential integers [0,1,2,3...]</span>
<span class="k">void</span> <a name="cmVOT_Lsq1"></a><span class="f">cmVOT_Lsq1</span><span class="p">(</span><span class="k">const</span> T_t<span class="p">*</span> <span class="i">x</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">y</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">n</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">b0</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">b1</span> <span class="p">)</span><span class="p">;</span>


<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Stretch/Shrink : Stretch or shrink a vector by resampling.</div><pre><a name="Stretch/Shrink"></a>
<span class="c">// Return the average value of the contents of sbp[] between two fractional indexes</span>
T_t  <a name="cmVOT_FracAvg"></a><span class="f">cmVOT_FracAvg</span><span class="p">(</span> <span class="k">double</span> <span class="i">bi</span><span class="p">,</span> <span class="k">double</span> <span class="i">ei</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Shrinking function - Decrease the size of sbp[] by averaging blocks of values into single values in dbp[]</span>
T_t<span class="p">*</span> <a name="cmVOT_DownSampleAvg"></a><span class="f">cmVOT_DownSampleAvg</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Stretching function - linear interpolate between points in sbp[] to fill dbp[] ... where dn &ampgt sn</span>
T_t<span class="p">*</span> <a name="cmVOT_UpSampleInterp"></a><span class="f">cmVOT_UpSampleInterp</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Stretch or shrink the sbp[] to fit into dbp[]</span>
T_t<span class="p">*</span> <a name="cmVOT_FitToSize"></a><span class="f">cmVOT_FitToSize</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Stretch or shrink sV[] to fit into dV[] using a simple linear mapping.
// When stretching (sn&ampltdn) each source element is repeated dn/sn times
// and the last fraction position is interpolated.  When shrinking 
// (sn&ampgtdn) each dest value is formed by the average of sequential segments
// of sn/dn source elements. Fractional values are used at the beginning
// and end of each segment.</span>
T_t<span class="p">*</span> <a name="cmVOT_LinearMap"></a><span class="f">cmVOT_LinearMap</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">sV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Random number generation : Generate random numbers.</div><pre><a name="Random number generation"></a>
<span class="c">// Generate a vector of uniformly distributed random numbers in the range minVal to maxVal.</span>
T_t<span class="p">*</span> <a name="cmVOT_Random"></a><span class="f">cmVOT_Random</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">minVal</span><span class="p">,</span> T_t <span class="i">maxVal</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Generate dn random numbers integers between 0 and wn-1 based on a the relative 
// weights in wp[wn].  Note thtat the weights do not have to sum to 1.0.</span>
<span class="k">unsigned</span><span class="p">*</span>  <a name="cmVOT_WeightedRandInt"></a><span class="f">cmVOT_WeightedRandInt</span><span class="p">(</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">wp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">wn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Generate a vector of normally distributed univariate random numbers </span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGauss"></a><span class="f">cmVOT_RandomGauss</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">mean</span><span class="p">,</span> T_t <span class="i">var</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Generate a vector of normally distributed univariate random numbers where each value has been drawn from a 
// seperately parameterized Gaussian distribution. meanV[] and varV[] must both contain dn velues.</span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGaussV"></a><span class="f">cmVOT_RandomGaussV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">varV</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Generate a matrix of multi-dimensional random values. Each column represents a single vector value and each row contains a dimension.
// meanV[] and varV[] must both contain drn elements where each meanV[i],varV[i] pair parameterize one dimensions Gaussian distribution.</span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGaussM"></a><span class="f">cmVOT_RandomGaussM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">varV</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGaussDiagM"></a><span class="f">cmVOT_RandomGaussDiagM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">diagCovarM</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Generate a matrix of multivariate random values drawn from a normal distribution.
// The dimensionality of the values are 'drn'.
// The count of returned values is 'dcn'.
// meanV[drn] and covarM[drn,drn] parameterize the normal distribution.
// The covariance matrix must be symetric and positive definite. 
// t[(drn*drn) ] points to scratch memory or is set to NULL if the function should
//   allocate the memory internally.
// Based on octave function mvrnd.m.</span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGaussNonDiagM"></a><span class="f">cmVOT_RandomGaussNonDiagM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">covarM</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">t</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Same as RandomGaussNonDiagM() except requires the upper trianglular 
// Cholesky factor of the covar matrix in 'uM'. </span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGaussNonDiagM2"></a><span class="f">cmVOT_RandomGaussNonDiagM2</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">uM</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Generate a matrix of N*K multi-dimensional data points.
// Where D is the dimensionality of the data. (D == drn).
// K is the number of multi-dimensional PDF's (clusters).
// N is the number of data points to generate per cluster. 
// dbp[ D, N*K ] contains the returned data point. 
// The first N columns is associated with the cluster 0, 
// the next N columns is associated with cluster 1, ...
// meanM[ D, K ] and varM[D,K] parameterize the generating PDF.s for each cluster</span>
T_t<span class="p">*</span> <a name="cmVOT_RandomGaussMM"></a><span class="f">cmVOT_RandomGaussMM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanM</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">varM</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">K</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Evaluate the univariate normal distribution defined by 'mean' and 'stdDev'.</span>
T_t<span class="p">*</span> <a name="cmVOT_GaussPDF"></a><span class="f">cmVOT_GaussPDF</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> T_t <span class="i">mean</span><span class="p">,</span> T_t <span class="i">stdDev</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Evaluate a multivariate normal distribution defined by meanV[D] and covarM[D,D]
// at the data points held in the columns of xM[D,N]. Return the evaluation
// results in the vector yV[N].  D is the dimensionality of the data. N is the number of
// data points to evaluate and values to return in yV[N]. 
// Set diagFl to true if covarM is diagonal.
// The function fails and returns false if the covariance matrix is singular.</span>
<span class="k">bool</span> <a name="cmVOT_MultVarGaussPDF"></a><span class="f">cmVOT_MultVarGaussPDF</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">yV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">xM</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">covarM</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">D</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">N</span><span class="p">,</span> <span class="k">bool</span> <span class="i">diagFl</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Same as multVarGaussPDF[] except takes the inverse covar mtx invCovarM[D,D] 
// and log determinant of covar mtx. 
// Always returns yV[].</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVarGaussPDF2"></a><span class="f">cmVOT_MultVarGaussPDF2</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">yV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">xM</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">invCovarM</span><span class="p">,</span> T_t <span class="i">logDet</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">D</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">N</span><span class="p">,</span> <span class="k">bool</span> <span class="i">diagFl</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Same as multVarGaussPDF[] except uses a function to obtain the data vectors.
// srcFunc() can filter the data points by returning NULL if the data vector at frmIdx should
// not be evaluated against the PDF. In this case yV[frmIdx] will be set to 0.</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVarGaussPDF3"></a>cmVOT_MultVarGaussPDF3<span class="p">(</span> 
T_t<span class="p">*</span>       <span class="i">yV</span><span class="p">,</span> 
<span class="k">const</span> T_t<span class="p">*</span> <span class="p">(</span><span class="p">*</span><span class="i">srcFunc</span><span class="p">)</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="i">funcDataPtr</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">frmIdx</span> <span class="p">)</span><span class="p">,</span>
<span class="k">void</span><span class="p">*</span>               <span class="i">funcDataPtr</span><span class="p">,</span>
<span class="k">const</span> T_t<span class="p">*</span> <span class="i">meanV</span><span class="p">,</span> 
<span class="k">const</span> T_t<span class="p">*</span> <span class="i">invCovarM</span><span class="p">,</span> 
T_t        <span class="i">logDet</span><span class="p">,</span> 
<span class="k">unsigned</span>            <span class="i">D</span><span class="p">,</span> 
<span class="k">unsigned</span>            <span class="i">N</span><span class="p">,</span> 
<span class="k">bool</span>                <span class="i">diagFl</span> <span class="p">)</span><span class="p">;</span>


<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Signal generators : Generate periodic signals.</div><pre><a name="Signal generators"></a>
<span class="c">// The following functions all return the phase of the next value. </span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthSine"></a><span class="f">cmVOT_SynthSine</span><span class="p">(</span>      T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthCosine"></a><span class="f">cmVOT_SynthCosine</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthSquare"></a><span class="f">cmVOT_SynthSquare</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">otCnt</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthTriangle"></a><span class="f">cmVOT_SynthTriangle</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">otCnt</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthSawtooth"></a><span class="f">cmVOT_SynthSawtooth</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">otCnt</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthPulseCos"></a><span class="f">cmVOT_SynthPulseCos</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">otCnt</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthImpulse"></a><span class="f">cmVOT_SynthImpulse</span><span class="p">(</span>   T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_SynthPhasor"></a><span class="f">cmVOT_SynthPhasor</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">phase</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">hz</span> <span class="p">)</span><span class="p">;</span> 


<span class="c">// Return value should be passed back via delaySmp on the next call.</span>
T_t  <a name="cmVOT_SynthPinkNoise"></a><span class="f">cmVOT_SynthPinkNoise</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">delaySmp</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Exponential conversion : pow() and log() functions.</div><pre><a name="Exponential conversion"></a>
<span class="c">// Raise dbp[] to the power 'expon'</span>
T_t<span class="p">*</span> <a name="cmVOT_PowVS"></a><span class="f">cmVOT_PowVS</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">expon</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_PowVVS"></a><span class="f">cmVOT_PowVVS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> T_t <span class="i">expon</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Take the natural log of all values in sbp[dn]. It is allowable for sbp point to the same array as dbp=.</span>
T_t<span class="p">*</span> <a name="cmVOT_LogV"></a><span class="f">cmVOT_LogV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">dB Conversions : Convert vectors between dB,linear and power representations.</div><pre><a name="dB Conversions"></a>
<span class="c">// Convert a magnitude (amplitude) spectrum to/from decibels. 
// It is allowable for dbp==sbp.</span>
T_t<span class="p">*</span> <a name="cmVOT_AmplToDbVV"></a><span class="f">cmVOT_AmplToDbVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> T_t <span class="i">minDb</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DbToAmplVV"></a><span class="f">cmVOT_DbToAmplVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">)</span><span class="p">;</span>

T_t<span class="p">*</span> <a name="cmVOT_PowToDbVV"></a><span class="f">cmVOT_PowToDbVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> T_t <span class="i">minDb</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DbToPowVV"></a><span class="f">cmVOT_DbToPowVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">)</span><span class="p">;</span>

T_t<span class="p">*</span> <a name="cmVOT_LinearToDb"></a><span class="f">cmVOT_LinearToDb</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> T_t <span class="i">mult</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_dBToLinear"></a><span class="f">cmVOT_dBToLinear</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> T_t <span class="i">mult</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_AmplitudeToDb"></a><span class="f">cmVOT_AmplitudeToDb</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_PowerToDb"></a><span class="f">cmVOT_PowerToDb</span><span class="p">(</span>     T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_dBToAmplitude"></a><span class="f">cmVOT_dBToAmplitude</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_dBToPower"></a><span class="f">cmVOT_dBToPower</span><span class="p">(</span>     T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">DSP Windows : DSP windowing functions.</div><pre><a name="DSP Windows"></a>
T_t  <a name="cmVOT_KaiserBetaFromSidelobeReject"></a><span class="f">cmVOT_KaiserBetaFromSidelobeReject</span><span class="p">(</span>  <span class="k">double</span> <span class="i">sidelobeRejectDb</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_KaiserFreqResolutionFactor"></a><span class="f">cmVOT_KaiserFreqResolutionFactor</span><span class="p">(</span> <span class="k">double</span> <span class="i">sidelobeRejectDb</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_Kaiser"></a><span class="f">cmVOT_Kaiser</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">double</span> <span class="i">beta</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span>	cmVOT_Gaussian<span class="p">(</span>T_t<span class="p">*</span> dbp<span class="p">,</span> <span class="k">unsigned</span> dn<span class="p">,</span> <span class="k">double</span> mean<span class="p">,</span> <span class="k">double</span> variance <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_Hamming"></a><span class="f">cmVOT_Hamming</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_Hann"></a><span class="f">cmVOT_Hann</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_Triangle"></a><span class="f">cmVOT_Triangle</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// The MATLAB equivalent Hamming and Hann windows.
//T_t* cmVOT_HammingMatlab(T_t* dbp, unsigned dn );</span>
T_t<span class="p">*</span> <a name="cmVOT_HannMatlab"></a><span class="f">cmVOT_HannMatlab</span><span class="p">(</span>   T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Simulates the MATLAB GaussWin function. Set arg to 2.5 to simulate the default arg
// as used by MATLAB.</span>
T_t<span class="p">*</span>	cmVOT_GaussWin<span class="p">(</span> T_t<span class="p">*</span> dbp<span class="p">,</span> <span class="k">unsigned</span> dn<span class="p">,</span> <span class="k">double</span> arg <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">DSP Filters : DSP filtering functions.</div><pre><a name="DSP Filters"></a>
<span class="c">// Direct form II algorithm based on the MATLAB implmentation
// http://www.mathworks.com/access/helpdesk/help/techdoc/ref/filter.html#f83-1015962
// The only difference between this function and the equivalent MATLAB filter() function
// is that the first feedforward coeff is given as a seperate value. The first  b coefficient
//  in this function is therefore the same as the second coefficient in the MATLAB function.
//  and the first a[] coefficient (which is generally set to 1.0) is skipped.
//  Example:
//  Matlab:         b=[.5 .4 .3]  a=[1 .2 .1]
//  Equiv:  b0 = .5 b=[   .4 .3]  a=[  .2 .1]; 
//
// y[yn] - output vector 
// x[xn] - input vector. xn must be &amplt= yn. if xn &amplt yn then the end of y[] is set to zero.
// b0 - signal scale. This can also be seen as b[0] (which is not included in b[])
// b[dn] - feedforward coeff's b[1..dn-1]
// a[dn] - feedback coeff's    a[1..dn-1]
// d[dn+1] - delay registers - note that this array must be one element longer than the coeff arrays.
// </span>
T_t<span class="p">*</span> <a name="cmVOT_Filter"></a><span class="f">cmVOT_Filter</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">y</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">yn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">x</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xn</span><span class="p">,</span> <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a> <span class="i">b0</span><span class="p">,</span> <span class="k">const</span> <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a><span class="p">*</span> <span class="i">b</span><span class="p">,</span> <span class="k">const</span> <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a><span class="p">*</span> <span class="i">a</span><span class="p">,</span>  <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a><span class="p">*</span> <span class="i">d</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>

<span class="k">struct</span> <span class="i"><a href="cmProc_h_0.html#cmFilter_str">cmFilter_str</a></span><span class="p">;</span>
<span class="c">//typedef <a href="cmGlobal_h_0.html#cmRC_t">cmRC_t</a> (*cmVOT_FiltExecFunc_t)( struct acFilter_str* f,  const T_t* x, unsigned xn, T_t* y, unsigned yn );</span>
T_t<span class="p">*</span> <a name="cmVOT_FilterFilter"></a><span class="f">cmVOT_FilterFilter</span><span class="p">(</span><span class="k">struct</span> <a href="cmProc_h_0.html#cmFilter_str">cmFilter_str</a><span class="p">*</span> <span class="i">f</span><span class="p">,</span> <a href="cmGlobal_h_0.html#cmRC_t">cmRC_t</a> <span class="p">(</span><span class="p">*</span><span class="i">func</span><span class="p">)</span><span class="p">(</span> <span class="k">struct</span> <a href="cmProc_h_0.html#cmFilter_str">cmFilter_str</a><span class="p">*</span> <span class="i">f</span><span class="p">,</span>  <span class="k">const</span> T_t<span class="p">*</span> <span class="i">x</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">y</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">yn</span> <span class="p">)</span><span class="p">,</span> <span class="k">const</span> <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a> bb<span class="p">[</span><span class="i">]</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bn</span><span class="p">,</span> <span class="k">const</span> <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a> aa<span class="p">[</span><span class="i">]</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">an</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">x</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">y</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">yn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Compute the coefficients of a low/high pass FIR filter
// wndV[dn] gives the window function used to truncate the ideal low-pass impulse response.
// Set wndV to NULL to use a unity window.
// See enum { kHighPass_LPSincFl=0x01, kNormalize_LPSincFl=0x02 } in cmVectOps.h</span>
T_t<span class="p">*</span> <a name="cmVOT_LP_Sinc"></a><span class="f">cmVOT_LP_Sinc</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">wndV</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">double</span> <span class="i">fcHz</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">flags</span> <span class="p">)</span><span class="p">;</span>



<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Spectral Masking : A collection of spectral masking functions.</div><pre><a name="Spectral Masking"></a>
<span class="c">// Compute a set of filterCnt mel filter masks for wieghting magnitude spectra consisting of binCnt bins.
// The spectrum is divided into bandCnt equal bands in the mel domain
// Each row of the matrix contains the mask for a single filter band consisting of binCnt elements.  
// See enum{ kShiftMelFl=0x01, kNormalizeMelFl=0x02 } in cmVectOps.h
// Set kShiftMelFl to shift the mel bands onto the nearest FFT bin.
// Set kNormalizeMelFl to normalize the combined filters for unity gain.</span>
T_t<span class="p">*</span> <a name="cmVOT_MelMask"></a><span class="f">cmVOT_MelMask</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">maskMtx</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bandCnt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">binCnt</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">flags</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Fill binIdxV[bandCnt] and cntV[bandCnt] with a bin to band map.
// binIdx[] contains the first (minimum) bin index for a given band.
// cntV[]   contains the count of bins for each band.
// bandCnt is the number of bark bands to return 
// The function returns the actual number of bands mapped which will always be &amplt= 23.</span>
<span class="k">unsigned</span> <a name="cmVOT_BarkMap"></a><span class="f">cmVOT_BarkMap</span><span class="p">(</span><span class="k">unsigned</span><span class="p">*</span> <span class="i">binIdxV</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">cntV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bandCnt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">binCnt</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Calc a set of triangle fitler masks into each row of maskMtx.
// maskMtx[ bandCnt, binCnt ] - result matrix
// binHz - freq resolution of the output filters.
// stSpread - Semi-tone spread above and below each center frequency (stSpread*2) is the total bandwidth. 
//            (Only used if lowHzV or uprHzV are NULL)
// lowHz[ bandCnt ] - set of upper frequency limits for each band.
// ctrHz[ bandCnt ] set to the center value in Hz for each band
// uprHz[ bandCnt ] - set of lower frequency limits for each band.
// Note if lowHz[] and uprHz[] are set to NULL then stSpread is used to set the bandwidth of each band.</span>
T_t<span class="p">*</span> <a name="cmVOT_TriangleMask"></a><span class="f">cmVOT_TriangleMask</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">maskMtx</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bandCnt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">binCnt</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">ctrHzV</span><span class="p">,</span> T_t <span class="i">binHz</span><span class="p">,</span> T_t <span class="i">stSpread</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">lowHzV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">uprHzV</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Calculate a set of Bark band triangle filters into maskMtx.
// Each row of maskMtx contains the filter for one band.
// maskMtx[ bandCnt, binCnt ]
// bandCnt - the number of triangle bankds. If bandCnt is &ampgt 24 it will be reduced to 24.
// binCnt - the number of bins in the filters.
// binHz - the width of each bin in Hz.</span>
T_t<span class="p">*</span> <a name="cmVOT_BarkMask"></a><span class="f">cmVOT_BarkMask</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">maskMtx</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bandCnt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">binCnt</span><span class="p">,</span> <span class="k">double</span> <span class="i">binHz</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Terhardt 1979 (Calculating virtual pitch, Hearing Research #1, pp 155-182)
// See enum { kNoTtmFlags=0, kModifiedTtmFl=0x01 } in cmVectOps.h</span>
T_t<span class="p">*</span> <a name="cmVOT_TerhardtThresholdMask"></a><span class="f">cmVOT_TerhardtThresholdMask</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">maskV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">binCnt</span><span class="p">,</span>  <span class="k">double</span> <span class="i">srate</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">flags</span><span class="p">)</span><span class="p">;</span>

<span class="c">//Schroeder et al., 1979, JASA, Optimizing digital speech coders by exploiting masking properties of the human ear</span>
T_t<span class="p">*</span> <a name="cmVOT_ShroederSpreadingFunc"></a><span class="f">cmVOT_ShroederSpreadingFunc</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">bandCnt</span><span class="p">,</span> <span class="k">double</span> <span class="i">srate</span><span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Machine learning : K-means clustering and Viterbi algorithms.</div><pre><a name="Machine learning"></a>
<span class="c">// Assign each data point to one of k clusters using an expectation-maximization algorithm.
// k gives the number of clusters to identify
// Each column of sp[ srn, scn ] contains a multidimensional data point. 
// srn therefore defines the dimensionality of the data.
// Each column of centroidV[ srn, k ] is set to the centroid of each of k clusters.
// classIdxV[ scn ] assigns the index (0 to k-1) of a cluster to each soure data point
// The function returns the number of iterations required for the EM process to converge.
// selIdxV[ scn ] is optional and contains a list of id's assoc'd with each column of sM.
// selKey is a integer value.
// If selIdxV is non-NULL then only columns of sM[] where selIdxV[] == selKey will be clustered.
// All columns of sM[] where the associated column in selIdxV[] do not match will be ignored.
// Set 'initFromCentroidFl' to true if the initial centroids should be taken from centroidM[].
// otherwise the initial centroids are selected from 'k' random data points in sp[].
// The distance function distFunc(cV,dV,dN) is called to determine the distance from a 
// centroid the centroid 'cV[dN]' to a data point 'dV[dN]'. 'dN' is the dimensionality of the
// feature vector and is therefore equal to 'srn'.</span>
<span class="k">unsigned</span> <a name="cmVOT_Kmeans"></a>cmVOT_Kmeans<span class="p">(</span> 
<span class="k">unsigned</span><span class="p">*</span>           <span class="i">classIdxV</span><span class="p">,</span> 
T_t<span class="p">*</span>       <span class="i">centroidM</span><span class="p">,</span> 
<span class="k">unsigned</span>            <span class="i">k</span><span class="p">,</span> 
<span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> 
<span class="k">unsigned</span>            <span class="i">srn</span><span class="p">,</span> 
<span class="k">unsigned</span>            <span class="i">scn</span><span class="p">,</span> 
<span class="k">const</span> <span class="k">unsigned</span><span class="p">*</span>     <span class="i">selIdxV</span><span class="p">,</span> 
<span class="k">unsigned</span>            <span class="i">selKey</span><span class="p">,</span> 
<span class="k">bool</span>                <span class="i">initFromCentroidFl</span><span class="p">,</span>  
T_t <span class="p">(</span><span class="p">*</span><span class="i">distFunc</span><span class="p">)</span><span class="p">(</span> <span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">cV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dN</span> <span class="p">)</span><span class="p">,</span> 
<span class="k">void</span><span class="p">*</span>               <span class="i">userDistPtr</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// 'srcFunc() should return NULL if the data point located at 'frmIdx' should not be included in the clustering.
// Clustering is considered to be complete after 'maxIterCnt' iterations or when
// 'deltaStopCnt' or fewer data points change class on a single iteration</span>
<span class="k">unsigned</span> <a name="cmVOT_Kmeans2"></a>cmVOT_Kmeans2<span class="p">(</span> 
<span class="k">unsigned</span><span class="p">*</span>           <span class="i">classIdxV</span><span class="p">,</span>         <span class="c"> // classIdxV[scn] - data point class assignments</span>
T_t<span class="p">*</span>       <span class="i">centroidM</span><span class="p">,</span>         <span class="c"> // centroidM[srn,K] - cluster centroids</span>
<span class="k">unsigned</span>            <span class="i">K</span><span class="p">,</span>                 <span class="c"> // count of clusters</span>
<span class="k">const</span> T_t<span class="p">*</span> <span class="p">(</span><span class="p">*</span><span class="i">srcFunc</span><span class="p">)</span><span class="p">(</span><span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">frmIdx</span> <span class="p">)</span><span class="p">,</span>
<span class="k">unsigned</span>            <span class="i">srn</span><span class="p">,</span>               <span class="c"> // dimensionality of each data point</span>
<span class="k">unsigned</span>            <span class="i">scn</span><span class="p">,</span>               <span class="c"> // count of data points</span>
<span class="k">void</span><span class="p">*</span>               <span class="i">userSrcPtr</span><span class="p">,</span>        <span class="c"> // callback data for srcFunc</span>
T_t <span class="p">(</span><span class="p">*</span><span class="i">distFunc</span><span class="p">)</span><span class="p">(</span> <span class="k">void</span><span class="p">*</span> <span class="i">userPtr</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">cV</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">dV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dN</span> <span class="p">)</span><span class="p">,</span> 
<span class="k">void</span><span class="p">*</span>              <span class="i">userDistPtr</span><span class="p">,</span>        <span class="c"> // arg. to distFunc()</span>
<span class="k">int</span>                <span class="i">iterCnt</span><span class="p">,</span>            <span class="c"> // max. number of iterations (-1 to ignore)</span>
<span class="k">int</span>                <span class="i">deltaStopCnt</span><span class="p">)</span><span class="p">;</span>      <span class="c"> // if less than deltaStopCnt data points change classes on a given iteration then convergence occurs.</span>

<span class="c">// Determine the most likely state sequece stateV[timeN] given a 
// transition matrix a[stateN,stateN], 
// observation probability matrix b[stateN,timeN] and 
// initial state probability vector phi[stateN].  
// a[i,j] is the probability of transitioning from state i to state j.
// b[i,t] is the probability of state i emitting the obj t.</span>
<span class="k">void</span> <a name="cmVOT_DiscreteViterbi"></a><span class="f">cmVOT_DiscreteViterbi</span><span class="p">(</span><span class="k">unsigned</span><span class="p">*</span> <span class="i">stateV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">timeN</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stateN</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">phi</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">a</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">b</span> <span class="p">)</span><span class="p">;</span>


<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Graphics : Graphics related algorithms.</div><pre><a name="Graphics"></a>
<span class="c">// Generate the set of coordinates which describe a circle with a center at x,y.
// dbp[dn,2] must contain 2*dn elements.  The first column holds the x coord and and the second holds the y coord.</span>
T_t<span class="p">*</span> <a name="cmVOT_CircleCoords"></a><span class="f">cmVOT_CircleCoords</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">x</span><span class="p">,</span> T_t <span class="i">y</span><span class="p">,</span> T_t <span class="i">varX</span><span class="p">,</span> T_t <span class="i">varY</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Clip the line defined by x0,y0 to x1,y1 into the rect defined by xMin,yMin xMax,yMax.</span>
<span class="k">bool</span> <a name="cmVOT_ClipLine"></a><span class="f">cmVOT_ClipLine</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">x0</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">y0</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">x1</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">y1</span><span class="p">,</span> T_t <span class="i">xMin</span><span class="p">,</span> T_t <span class="i">yMin</span><span class="p">,</span> T_t <span class="i">xMax</span><span class="p">,</span> T_t <span class="i">yMax</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return true if the line defined by x0,y0 to x1,y1 intersects with
// the rectangle formed by xMin,yMin - xMax,yMax</span>
<span class="k">bool</span> <a name="cmVOT_IsLineInRect"></a><span class="f">cmVOT_IsLineInRect</span><span class="p">(</span> T_t <span class="i">x0</span><span class="p">,</span> T_t <span class="i">y0</span><span class="p">,</span> T_t <span class="i">x1</span><span class="p">,</span> T_t <span class="i">y1</span><span class="p">,</span> T_t <span class="i">xMin</span><span class="p">,</span> T_t <span class="i">yMin</span><span class="p">,</span> T_t <span class="i">xMax</span><span class="p">,</span> T_t <span class="i">yMax</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Return the perpendicular distance from the line formed by x0,y0 and x1,y1
// and the point px,py</span>
T_t <a name="cmVOT_PtToLineDistance"></a><span class="f">cmVOT_PtToLineDistance</span><span class="p">(</span> T_t <span class="i">x0</span><span class="p">,</span> T_t <span class="i">y0</span><span class="p">,</span> T_t <span class="i">x1</span><span class="p">,</span> T_t <span class="i">y1</span><span class="p">,</span> T_t <span class="i">px</span><span class="p">,</span> T_t <span class="i">py</span><span class="p">)</span><span class="p">;</span>                              

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Miscellaneous DSP : Common DSP algorithms.</div><pre><a name="Miscellaneous DSP"></a>
<span class="c">// Compute the complex transient detection function from successive spectral frames.
// The spectral magntidue mag0V precedes mag1V and the phase (radians) spectrum phs0V precedes the phs1V which precedes phs2V.  
// binCnt gives the length of each of the spectral vectors.</span>
T_t  <a name="cmVOT_ComplexDetect"></a><span class="f">cmVOT_ComplexDetect</span><span class="p">(</span><span class="k">const</span> T_t<span class="p">*</span> <span class="i">mag0V</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">mag1V</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">phs0V</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">phs1V</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">phs2V</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">binCnt</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Compute a set of DCT-II coefficients. Result dp[ coeffCnt, filtCnt ]</span>
T_t<span class="p">*</span> <a name="cmVOT_DctMatrix"></a><span class="f">cmVOT_DctMatrix</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">coeffCnt</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">filtCnt</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Set the indexes of local peaks greater than threshold in dbp[].
// Returns the number of peaks in dbp[]
// The maximum number of peaks from n source values is max(0,floor((n-1)/2)).
// Note that peaks will never be found at index 0 or index sn-1.</span>
<span class="k">unsigned</span> <a name="cmVOT_PeakIndexes"></a><span class="f">cmVOT_PeakIndexes</span><span class="p">(</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> T_t <span class="i">threshold</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the index of the bin containing v otherwise return kInvalidIdx if v is below sbp[0] or above sbp[ n-1 ]
// The bin limits are contained in sbp[].
// The value in spb[] are therefore expected to be in increasing order.
// The value returned will be in the range 0:sn-1.</span>
<span class="k">unsigned</span> <a name="cmVOT_BinIndex"></a><span class="f">cmVOT_BinIndex</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> T_t <span class="i">v</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Given the points x0[xy0N],y0[xy0N] fill y1[i] with the interpolated value of y0[] at
// x1[i].  Note that x0[] and x1[] must be increasing monotonic.
// This function is similar to the octave interp1() function.</span>
<span class="k">void</span> <a name="cmVOT_Interp1"></a><span class="f">cmVOT_Interp1</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">y1</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">x1</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xy1N</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">x0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">y0</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xy0N</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Matrix ops : Common 2D matrix operations and accessors.</div><pre><a name="Matrix ops"></a>
<span class="c">// 2D matrix accessors</span>
T_t<span class="p">*</span> <a name="cmVOT_Col"></a><span class="f">cmVOT_Col</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_Row"></a><span class="f">cmVOT_Row</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_ElePtr"></a><span class="f">cmVOT_ElePtr</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_Ele"></a><span class="f">cmVOT_Ele</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
<span class="k">void</span>          <a name="cmVOT_Set"></a><span class="f">cmVOT_Set</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span><span class="p">,</span> T_t <span class="i">v</span> <span class="p">)</span><span class="p">;</span>

<span class="k">const</span> T_t<span class="p">*</span> <a name="cmVOT_CCol"></a><span class="f">cmVOT_CCol</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
<span class="k">const</span> T_t<span class="p">*</span> <a name="cmVOT_CRow"></a><span class="f">cmVOT_CRow</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
<span class="k">const</span> T_t<span class="p">*</span> <a name="cmVOT_CElePtr"></a><span class="f">cmVOT_CElePtr</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>
T_t        <a name="cmVOT_CEle"></a><span class="f">cmVOT_CEle</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ri</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">ci</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Set only the diagonal of a square mtx to sbp.</span>
T_t<span class="p">*</span> <a name="cmVOT_Diag"></a><span class="f">cmVOT_Diag</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">n</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Set the diagonal of a square mtx to db to sbp and set all other values to zero.</span>
T_t<span class="p">*</span> <a name="cmVOT_DiagZ"></a><span class="f">cmVOT_DiagZ</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">n</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c">// Create an identity matrix (only sets 1's not zeros).</span>
T_t<span class="p">*</span> <a name="cmVOT_Identity"></a><span class="f">cmVOT_Identity</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Zero the matrix and then fill it as an identity matrix.</span>
T_t<span class="p">*</span> <a name="cmVOT_IdentityZ"></a><span class="f">cmVOT_IdentityZ</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">rn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">cn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Transpose the matrix sbp[srn,scn] into dbp[scn,srn]</span>
T_t<span class="p">*</span> <a name="cmVOT_Transpose"></a><span class="f">cmVOT_Transpose</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Fill,move,copy : Basic data movement and initialization.</div><pre><a name="Fill,move,copy"></a>
<span class="c">// Fill a vector with a value. If value is 0 then the function is accellerated via memset().</span>
T_t<span class="p">*</span> <a name="cmVOT_Fill"></a><span class="f">cmVOT_Fill</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">value</span>  <span class="p">)</span><span class="p">;</span>

<span class="c">// Fill a vector with zeros</span>
T_t<span class="p">*</span> <a name="cmVOT_Zero"></a><span class="f">cmVOT_Zero</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span>  <span class="p">)</span><span class="p">;</span>

<span class="c">// Analogous to memmove()</span>
T_t<span class="p">*</span> <a name="cmVOT_Move"></a><span class="f">cmVOT_Move</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Fill the vector from various sources</span>
T_t<span class="p">*</span> <a name="cmVOT_Copy"></a><span class="f">cmVOT_Copy</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyN"></a><span class="f">cmVOT_CopyN</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">d_stride</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">s_stride</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyU"></a><span class="f">cmVOT_CopyU</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyI"></a><span class="f">cmVOT_CopyI</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> <span class="k">int</span><span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyF"></a><span class="f">cmVOT_CopyF</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> <span class="k">float</span><span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyD"></a><span class="f">cmVOT_CopyD</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> <span class="k">double</span><span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyS"></a><span class="f">cmVOT_CopyS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> <a href="cmFloatTypes_h_0.html#cmSample_t">cmSample_t</a><span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_CopyR"></a><span class="f">cmVOT_CopyR</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> <a href="cmFloatTypes_h_0.html#cmReal_t">cmReal_t</a><span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Fill the the destination vector from a source vector where the source vector contains
// srcStride interleaved elements to be ignored. </span>
T_t<span class="p">*</span> <a name="cmVOT_CopyStride"></a><span class="f">cmVOT_CopyStride</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srcStride</span> <span class="p">)</span><span class="p">;</span>


<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Shrink/Expand/Replace : Change the size of a vector.</div><pre><a name="Shrink/Expand/Replace"></a>

<span class="c">// Shrink the elemetns of dbp[dn] by copying all elements past t+tn to t.
// This operation results in overwriting the elements in the range t[tn].
// t[tn] must be entirely inside dbp[dn].</span>
T_t<span class="p">*</span> <a name="cmVOT_Shrink"></a><span class="f">cmVOT_Shrink</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">t</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">tn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Expand dbp[[dn] by shifting all elements past t to t+tn.
// This produces a set of empty elements in t[tn].
// t must be inside or at the end of dbp[dn].
// This results in a reallocation of dbp[]. Be sure to call <a href="cmMallocDebug_h_0.html#cmMemFree">cmMemFree</a>(dbp)
// to release the returned pointer.</span>
T_t<span class="p">*</span> <a name="cmVOT_Expand"></a><span class="f">cmVOT_Expand</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">t</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">tn</span> <span class="p">)</span><span class="p">;</span>                                                            

<span class="c">// Replace the elements t[tn] with the elements in u[un]. 
// t must be inside or at the end of dbp[dn].
// This operation may result in a reallocation of dbp[]. Be sure to call <a href="cmMallocDebug_h_0.html#cmMemFree">cmMemFree</a>(dbp)
// to release the returned pointer.
// IF dbp==NULL and tn==0 then the dbp[un] is allocated and returned 
// with the contents of u[un].</span>
T_t<span class="p">*</span> <a name="cmVOT_Replace"></a><span class="f">cmVOT_Replace</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">t</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">tn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">u</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">un</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Rotate/Shift/Flip/Sequence : Modify/generate the vector sequence.</div><pre><a name="Rotate/Shift/Flip/Sequence"></a>
<span class="c">// Assuming a row vector positive shiftCnt rotates right, negative shiftCnt rotates left.</span>
T_t<span class="p">*</span> <a name="cmVOT_Rotate"></a><span class="f">cmVOT_Rotate</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">int</span> <span class="i">shiftCnt</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Equivalent to Matlab circshift().</span>
T_t<span class="p">*</span> <a name="cmVOT_RotateM"></a><span class="f">cmVOT_RotateM</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> <span class="k">int</span> <span class="i">rShift</span><span class="p">,</span> <span class="k">int</span> <span class="i">cShift</span>  <span class="p">)</span><span class="p">;</span>

<span class="c">// Assuming a row vector positive shiftCnt shifts right, negative shiftCnt shifts left.</span>
T_t<span class="p">*</span> <a name="cmVOT_Shift"></a><span class="f">cmVOT_Shift</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">int</span> <span class="i">shiftCnt</span><span class="p">,</span> T_t <span class="i">fill</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Reverse the contents of the vector.</span>
T_t<span class="p">*</span> <a name="cmVOT_Flip"></a><span class="f">cmVOT_Flip</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">)</span><span class="p">;</span>

<span class="c">// Fill dbp[] with a sequence of values. Returns next value. </span>
T_t  <a name="cmVOT_Seq"></a><span class="f">cmVOT_Seq</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">beg</span><span class="p">,</span> T_t <span class="i">incr</span> <span class="p">)</span><span class="p">;</span>




<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Arithmetic : Add,Sub,Mult,Divde</div><pre><a name="Arithmetic"></a>
T_t<span class="p">*</span> <a name="cmVOT_SubVS"></a><span class="f">cmVOT_SubVS</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">v</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_SubVV"></a><span class="f">cmVOT_SubVV</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">v</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_SubVVS"></a><span class="f">cmVOT_SubVVS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">v</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_SubVVNN"></a><span class="f">cmVOT_SubVVNN</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dnn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">snn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_SubVVV"></a><span class="f">cmVOT_SubVVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_SubVSV"></a><span class="f">cmVOT_SubVSV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t  <span class="i">s0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>

T_t<span class="p">*</span> <a name="cmVOT_AddVS"></a><span class="f">cmVOT_AddVS</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">v</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_AddVV"></a><span class="f">cmVOT_AddVV</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">v</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_AddVVS"></a><span class="f">cmVOT_AddVVS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">v</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_AddVVNN"></a><span class="f">cmVOT_AddVVNN</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dnn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">snn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_AddVVV"></a><span class="f">cmVOT_AddVVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>

T_t<span class="p">*</span> <a name="cmVOT_MultVVV"></a><span class="f">cmVOT_MultVVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVV"></a><span class="f">cmVOT_MultVV</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVVNN"></a><span class="f">cmVOT_MultVVNN</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span>  <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dnn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">snn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVS"></a><span class="f">cmVOT_MultVS</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVVS"></a><span class="f">cmVOT_MultVVS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_MultVaVS"></a><span class="f">cmVOT_MultVaVS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_MultSumVVS"></a><span class="f">cmVOT_MultSumVVS</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sbp</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>

T_t<span class="p">*</span> <a name="cmVOT_DivVVS"></a><span class="f">cmVOT_DivVVS</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span><span class="p">,</span> T_t <span class="i">sb1</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVVV"></a><span class="f">cmVOT_DivVVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVV"></a><span class="f">cmVOT_DivVV</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVVNN"></a><span class="f">cmVOT_DivVVNN</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span>  <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dnn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">snn</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVS"></a><span class="f">cmVOT_DivVS</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> T_t <span class="i">s</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVSV"></a><span class="f">cmVOT_DivVSV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span>  <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t  <span class="i">s0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Set dest to 0 if denominator is 0.</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVVVZ"></a><span class="f">cmVOT_DivVVVZ</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb1p</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span> <a name="cmVOT_DivVVZ"></a><span class="f">cmVOT_DivVVZ</span><span class="p">(</span>  T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sb0p</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Divide columns of dp[:,i] by each value in the source vector sp[i]. </span>
T_t<span class="p">*</span>  <a name="cmVOT_DivMS"></a><span class="f">cmVOT_DivMS</span><span class="p">(</span>    T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">drn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dcn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span> 

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Sum vectors : Operations which take sum vector elements.</div><pre><a name="Sum vectors"></a>
T_t  <a name="cmVOT_Sum"></a><span class="f">cmVOT_Sum</span><span class="p">(</span>      <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_SumN"></a><span class="f">cmVOT_SumN</span><span class="p">(</span>     <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Sum the columns of sp[srn,scn] into dp[scn]. 
// dp[] is zeroed prior to computing the sum.</span>
T_t<span class="p">*</span>  <a name="cmVOT_SumM"></a><span class="f">cmVOT_SumM</span><span class="p">(</span>     <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">dp</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Sum the rows of sp[srn,scn] into dp[srn]
// dp[] is zeroed prior to computing the sum.</span>
T_t<span class="p">*</span>  <a name="cmVOT_SumMN"></a><span class="f">cmVOT_SumMN</span><span class="p">(</span>    <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">dp</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Min/max/median/mode : Simple descriptive statistics.</div><pre><a name="Min/max/median/mode"></a>
T_t  <a name="cmVOT_Median"></a><span class="f">cmVOT_Median</span><span class="p">(</span>   <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_MinIndex"></a><span class="f">cmVOT_MinIndex</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span>      <a name="cmVOT_MaxIndex"></a><span class="f">cmVOT_MaxIndex</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_Min"></a><span class="f">cmVOT_Min</span><span class="p">(</span>      <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span> <span class="p">)</span><span class="p">;</span>
T_t  <a name="cmVOT_Max"></a><span class="f">cmVOT_Max</span><span class="p">(</span>      <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">stride</span> <span class="p">)</span><span class="p">;</span>

T_t<span class="p">*</span>  <a name="cmVOT_MinVV"></a><span class="f">cmVOT_MinVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>
T_t<span class="p">*</span>  <a name="cmVOT_MaxVV"></a><span class="f">cmVOT_MaxVV</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Return index of max/min value into dp[scn] of each column of sp[srn,scn]</span>
<span class="k">unsigned</span><span class="p">*</span>  <a name="cmVOT_MinIndexM"></a><span class="f">cmVOT_MinIndexM</span><span class="p">(</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span> <span class="p">)</span><span class="p">;</span>
<span class="k">unsigned</span><span class="p">*</span>  <a name="cmVOT_MaxIndexM"></a><span class="f">cmVOT_MaxIndexM</span><span class="p">(</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">srn</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">scn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the most frequently occuring element in sp.</span>
T_t  <a name="cmVOT_Mode"></a><span class="f">cmVOT_Mode</span><span class="p">(</span>     <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Compare/Find : Compare, find, replace and count elements in a vector.</div><pre><a name="Compare/Find"></a>
<span class="c">// Return true if s0p[sn] is equal to s1p[sn]</span>
<span class="k">bool</span>       <a name="cmVOT_IsEqual"></a><span class="f">cmVOT_IsEqual</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return true if all elements of s0p[sn] are within 'eps' of s1p[sn].
// This function is based on <a href="cmMath_h_0.html#cmMath.h">cmMath.h</a>:cmIsCloseX()</span>
<span class="k">bool</span> <a name="cmVOT_IsClose"></a><span class="f">cmVOT_IsClose</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0p</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1p</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> <span class="k">double</span> <span class="i">eps</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Replace all values &amplt= lteKeyVal with replaceVal.  sp==dp is legal.</span>
T_t<span class="p">*</span> <a name="cmVOT_ReplaceLte"></a><span class="f">cmVOT_ReplaceLte</span><span class="p">(</span> T_t<span class="p">*</span> <span class="i">dp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> T_t <span class="i">lteKeyVal</span><span class="p">,</span> T_t <span class="i">replaceVal</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the index of 'key' in sp[sn] or <a href="cmGlobal_h_0.html#cmInvalidIdx">cmInvalidIdx</a> if 'key' does not exist.</span>
<span class="k">unsigned</span> <a name="cmVOT_Find"></a><span class="f">cmVOT_Find</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> T_t <span class="i">key</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Count the number of times 'key' occurs in sp[sn].</span>
<span class="k">unsigned</span> <a name="cmVOT_Count"></a><span class="f">cmVOT_Count</span><span class="p">(</span><span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">sn</span><span class="p">,</span> T_t <span class="i">key</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Absolute value : Absolute value and signal rectification.</div><pre><a name="Absolute value"></a>
T_t<span class="p">*</span>   <a name="cmVOT_Abs"></a><span class="f">cmVOT_Abs</span><span class="p">(</span>   T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Half wave rectify the source vector.
// dbp[] = sbp&amplt0 .* sbp 
// Overlapping the source and dest is allowable as long as dbp &amplt= sbp. </span>
T_t<span class="p">*</span> <a name="cmVOT_HalfWaveRectify"></a><span class="f">cmVOT_HalfWaveRectify</span><span class="p">(</span>T_t<span class="p">*</span> <span class="i">dbp</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">dn</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">sp</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Filter : Apply filtering to a vector taking into account vector begin/end conditions.</div><pre><a name="Filter"></a>
<span class="c">// Apply a median or other filter of order wndN to xV[xN] and store the result in yV[xN].
// When the window goes off either side of the vector the window is shortened.
// This algorithm produces the same result as the fn_thresh function in MATLAB fv codebase.</span>
<span class="k">void</span> <a name="cmVOT_FnThresh"></a><span class="f">cmVOT_FnThresh</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">xV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xN</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">wndN</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">yV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">yStride</span><span class="p">,</span> T_t <span class="p">(</span><span class="p">*</span><span class="i">fnPtr</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> T_t<span class="i">*</span><span class="p">,</span> <span class="i">unsigned</span><span class="p">)</span> <span class="p">)</span><span class="p">;</span>


<span class="c">// Apply a median filter of order wndN  to xV[xN] and store the result in yV[xN].
// When the window goes off either side of the vector the missing elements are considered
// to be 0.
// This algorithm produces the same result as the MATLAB medfilt1() function.</span>
<span class="k">void</span> <a name="cmVOT_MedianFilt"></a><span class="f">cmVOT_MedianFilt</span><span class="p">(</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">xV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">xN</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">wndN</span><span class="p">,</span> T_t<span class="p">*</span> <span class="i">yV</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">yStride</span> <span class="p">)</span><span class="p">;</span>
<span class="c"><hr id="hr2"></span></pre>
</div>
<div class="cod"><div class="blk_title">Edit distance : Calculate the Levenshtein edit distance between vectors.</div><pre><a name="Edit distance"></a>
<span class="c">// Allocate and initialize a matrix for use by LevEditDist().
// This matrix can be released with a call to <a href="cmMallocDebug_h_0.html#cmMemFree">cmMemFree</a>().</span>
<span class="k">unsigned</span><span class="p">*</span> <a name="cmVOT_LevEditDistAllocMtx"></a><span class="f">cmVOT_LevEditDistAllocMtx</span><span class="p">(</span><span class="k">unsigned</span> <span class="i">mtxMaxN</span><span class="p">)</span><span class="p">;</span>

<span class="c">// Return the Levenshtein edit distance between two vectors.
// m must point to a matrix pre-allocated by cmVOT_InitiLevEditDistMtx(maxN).</span>
<span class="k">double</span>  <a name="cmVOT_LevEditDist"></a><span class="f">cmVOT_LevEditDist</span><span class="p">(</span><span class="k">unsigned</span> <span class="i">mtxMaxN</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0</span><span class="p">,</span> <span class="k">int</span> <span class="i">n0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1</span><span class="p">,</span> <span class="k">int</span> <span class="i">n1</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">maxN</span> <span class="p">)</span><span class="p">;</span>

<span class="c">// Return the Levenshtein edit distance between two vectors.
// Edit distance with a max cost threshold. This version of the algorithm
// will run faster than LevEditDist() because it will stop execution as soon
// as the distance exceeds 'maxCost'.
// 'maxCost' must be between 0.0 and 1.0 or it is forced into this range.
// The maximum distance returned will be 'maxCost'.
// m must point to a matrix pre-allocated by cmVOT_InitiLevEditDistMtx(maxN).</span>
<span class="k">double</span> <a name="cmVOT_LevEditDistWithCostThresh"></a><span class="f">cmVOT_LevEditDistWithCostThresh</span><span class="p">(</span> <span class="k">int</span> <span class="i">mtxMaxN</span><span class="p">,</span> <span class="k">unsigned</span><span class="p">*</span> <span class="i">m</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s0</span><span class="p">,</span> <span class="k">int</span> <span class="i">n0</span><span class="p">,</span> <span class="k">const</span> T_t<span class="p">*</span> <span class="i">s1</span><span class="p">,</span> <span class="k">int</span> <span class="i">n1</span><span class="p">,</span> <span class="k">double</span> <span class="i">maxCost</span><span class="p">,</span> <span class="k">unsigned</span> <span class="i">maxN</span> <span class="p">)</span><span class="p">;</span>

<span class="c"><hr id="hr2"></span></pre>
</div>
<!-- End nodes -->
</div>
</body>
</html>
